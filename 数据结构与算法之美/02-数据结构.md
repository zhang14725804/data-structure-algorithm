### 01、数组

- 第一：线性表(Linear List)。顾名思义,线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组,链表、队
列、栈等也是线性表结构。

- 第二：连续的内存空间和相同类型的数据。正是因为这两个限制,它才有了一个堪称“杀手锏”的特性:“随机访问”。但有利就有弊,这两个限制也让数组的很多
操作变得非常低效,比如要想在数组中删除、插入一个数据,为了保证连续性,就需要做大量的数据搬移工作。（todo：如何规避低效的插入（先移动后替换）和删除（多次操作合并））

- 为什么大多数编程语言中,数组要从0开始编号,而不是从1开始呢?

    从数组存储的内存模型上来看,“下标”最确切的定义应该是“**偏移(offset)**”。前面也讲到,如果用a来表示数组的首地址,a[0]就是偏移为0的位置,也就是首地
    址,a[k]就表示偏移k个type_size的位置,所以计算a[k]的内存地址只需要用这个公式:

    a[k]_address = base_address + k * type_size

    但是,如果数组从1开始计数,那我们计算数组元素a[k]的内存地址就会变为:

    a[k]_address = base_address + (k-1)*type_size

    对比两个公式,我们不难发现,从1开始编号,每次随机访问数组元素都多了一次减法运算,对于CPU来说,就是多了一次减法指令。

    数组作为非常基础的数据结构,通过下标随机访问数组元素又是其非常基础的编程操作,效率的优化就要尽可能做到极致。所以为了减少一次减法操作,数组选
    择了从0开始编号,而不是从1开始。


### 02、链表（常见的：单链表、双链表、循环链表（首尾相连））

缓存的大小有限,当缓存被用满时,哪些数据应该被清理出去,哪些数据应该被保留?这就需要缓存淘汰策略来决定。常见的策略有三种:
**先进先出策略FIFO(First In,First Out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)**。

数组简单易用,在实现上使用的是连续的内存空间,可以借助**CPU的缓存机制**（todo：这是什么鬼）,预读数组中的数据,所以访问效率更高。而链表在内存中并不是连续存储,所以
对CPU缓存不友好,没办法有效预读。

CPU在从内存读取数据的时候,会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址,而是读取一个
数据块(这个大小我不太确定。。)并保存到CPU缓存中,然后下次访问内存数据的时候就会先从CPU缓存开始查找,如果找到就不需要再从内存中取。这样
就实现了比内存访问速度更快的机制,也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说,存储空间是连续的,所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存
储。

怎么理解指针：

    将某个变量赋值给指针,实际上就是将这个变量的地址赋值给指针,或者反过来说,指针中存储了这个变量的内存地址,指向了这个变量,通过指针就能找到这个变量。
