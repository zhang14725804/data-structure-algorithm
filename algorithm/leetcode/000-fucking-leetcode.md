### 1、动态规划

符合动态规划的特征：**重叠子问题、最优子结构**

可分为三类：线性、区间、背包问题

- 动态规划、递归、回溯

    递归：自顶向下，存在重叠子问题
    dp：自底向上；cache或DP table解决递归中的重叠子问题；穷举+剪枝

**动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题**

- 套路1

dp问题可分为：状态表示（分为：集合，属性）和状态计算

- 套路2

如何列出正确的状态转移方程？

    （1）确定 base case
    （2）确定「状态」，也就是原问题和子问题中会变化的变量
    （3）确定「选择」，也就是导致「状态」产生变化的行为
    （4）明确 dp 函数/数组的定义

- question

    （1）遍历方向；有时候正向(72)，有时候反向(516)
    （2）开辟dp数组；有时开辟n+1,m+1的空间(72)，有时开辟n空间(516)
    （3）如何进行状态压缩
    （4）背包问题(494)

只要涉及子序列问题，十有八九都需要动态规划来解决  


**1.3、1.4、1.5**

### 2、Top-K问题（四板斧）

参考：https://zhuanlan.zhihu.com/p/114699207

- 快速排序变形

    找前K大/前K小/第K大/第K小，是不需要对整个数组进行O(NlogN)的排序的！因为可以通过快排切分直接O(N)找到第K大的数

- 二叉堆（优先队列）

- 计数排序

- 桶排序

### 3、回溯算法

DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置

只需要思考 3 个问题：

	1、路径：也就是已经做出的选择。
	2、选择列表：也就是你当前可以做的选择。
	3、结束条件：也就是到达决策树底层，无法再做选择的条件。

其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」

- 具体题目

        22.括号生成
        37.解数独
        77.组合
        78.子集
        46.全排列问题
        51.n皇后问题

todo:还可以通过剪枝进行优化

### 4、BFS

### 5、数学技巧

## 6、二分法

- 二分法特征

    存在单调性
    存在二段性

- 二分的流程

    (1)确定边界
    (2)代码框架
    (3)设置check
    (4)判断区间如何更新
    (5)注意mid取值

- 两个模板

（1）下取整

当我们将区间 **[l, r]** 划分成 **[l, mid]** 和 **[mid + 1, r]** 时，其更新操作是 **r = mid** 或者 **l = mid + 1** ;，计算mid时不需要加1。

这种通常题目描述为 **满足某种情况的最小的元素。是否存在一个目标值（精确查找）**

```golang
func bsearch1(l,r int){
    while(l<r){
        mid := (l+r) >> 1
        if check(mid){
            r = mid
        }else{
            l = mid+1
        }
    }
    return l
}
```

（2）上取整

当我们将区间 **[l, r]** 划分成 **[l, mid - 1]** 和 **[mid, r]** 时，其更新操作是 **r = mid - 1** 或者 **l = mid**;，此时为了防止死循环，计算mid时需要加1。

这种通常题目描述为 **满足某种情况的最大的元素**，069题（mid*mid <= x）

```golang
func bsearch2(l,r int){
    while(l<r){
        mid := (l+r+1) >> 1
        if check(mid){
            l = mid
        }else{
            r = mid-1
        }
    }
    return l
}
```

假设有一个总区间，经由我们的 check 函数判断后，可分成两部分，
这边以o作 true，.....作 false 示意较好识别

如果我们的目标是下面这个v，那麽就必须使用 **模板1**

................vooooooooo

假设经由 check 划分后，整个区间的属性与目标v如下，则我们必须使用 **模板2**

oooooooov...................


### 7、分治思想

### 8、滑动窗口

思考以下四个问题：

    1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？
    2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？
    3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？
    4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

- 具体题目

    76.最小覆盖子串
    567.字符串的排列
    438.找到字符串中所有字母异位词
    3.最长无重复子串

### 9、单调队列、单调栈

### 10、双指针

    先暴力----> 寻找单调性 ----> 优化

- 具体题目

        167.两数之和 II - 输入有序数组
        88.合并两个有序数组（解题方法很巧妙）
        26.删除排序数组中的重复项
        76.最小覆盖子串（上来就优化，没懂😅）
        32.最长有效括号


### 11、状态机（动态规划）

- 股票买卖

这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）

想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润

为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

(1) 状态转移方程

    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])

	解释：今天我没有持有股票，有两种可能：

        要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
        要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

	dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

	解释：今天我持有着股票，有两种可能：

        要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
        要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。


    
(2) base case

        dp[-1][k][0] = 0
        解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
        dp[-1][k][1] = -infinity
        解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
        dp[i][0][0] = 0
        解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
        dp[i][0][1] = -infinity
        解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。


具体题目

    121
    122
    123
    188
    309(base case有问题)
    714(状态转移有问题)