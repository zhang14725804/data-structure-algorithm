### 1、动态规划

### 2、Top-K问题（四板斧）

### 3、回溯算法

### 4、BFS和DFS

### 5、数学技巧

## 6、二分法

### 7、分治思想

### 8、滑动窗口

思考以下四个问题：

    1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？
    2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？
    3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？
    4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

- 具体题目

    76.最小覆盖子串
    567.字符串的排列
    438.找到字符串中所有字母异位词
    3.最长无重复子串

### 9、单调队列、单调栈

### 10、双指针

    先暴力----> 寻找单调性 ----> 优化

- 具体题目

        167.两数之和 II - 输入有序数组
        88.合并两个有序数组（解题方法很巧妙）
        26.删除排序数组中的重复项
        76.最小覆盖子串（上来就优化，没懂😅）
        32.最长有效括号


### 11、状态机（动态规划）

- 股票买卖

这个问题的【状态】有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）

想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润

为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

(1) 状态转移方程

    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])

	解释：今天我没有持有股票，有两种可能：

        要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
        要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

	dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

	解释：今天我持有着股票，有两种可能：

        要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
        要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。


    
(2) base case

        dp[-1][k][0] = 0
        解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
        dp[-1][k][1] = -infinity
        解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
        dp[i][0][0] = 0
        解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
        dp[i][0][1] = -infinity
        解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。


具体题目

    121
    122
    123
    188
    309(base case有问题)
    714(状态转移有问题)


### 12、nSum问题

核心算法：双指针

递归 + 2Sum最终实现nSum问题

### 13、树（二叉树）问题

（1）二叉树遍历问题：前序遍历，中序遍历，后序遍历（相对于根元素来将）；层序遍历（宽度优先遍历）

```golang
    // 递归实现（🔥🔥🔥）
    traverse(root *TreeNode) {
        // 前序遍历
        traverse(root.Left)
        // 中序遍历
        traverse(root.Right)
        // 后序遍历
    }

    // 迭代实现（🔥🔥🔥）
    traverse(root *TreeNode) {
        if root == nil {
            return root
        }
        queue := make([]*TreeNode, 0)
        queue = append(queue, root)
        for len(queue) > 0 {
            node := queue[0]
            queue = queue[1:]
            // 层序遍历
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
```

所有回溯、动归、分治算法，其实都是树的问题


    【快速排序】就是个二叉树的【前序遍历】，【归并排序】就是个二叉树的【后续遍历】

快速排序：先构造分界点，然后去左右子数组构造分界点

归并排序：先对左右子数组排序，然后合并（类似合并有序链表的逻辑）

（2）写递归算法的秘诀

    写递归算法的关键是要明确函数的【定义】是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

写树相关的算法，简单说就是，先搞清楚当前 root 节点该做什么，然后根据函数定义递归调用子节点

二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情。

写二叉树的算法题，都是基于递归框架的，我们先要搞清楚 root 节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。

（3）搜索二叉树

BST特性（🔥🔥🔥）：中序遍历结果是有序的（升序）

直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

```golang
    // BST增删改查套路 
    func BST(root *TreeNode, target int) *TreeNode {
        if root.Val == target {
            // 目标节点
        } else if root.Val > target {
            BST(root.Left, target)
        } else if root.Val < target {
            BST(root.Right, target)
        }
    }
```

总结：

**把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了**

### 14、数据结构

（1）数据的存储方式：数组（顺序存储）和链表（链式存储）

不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？**分析问题，一定要有递归的思想，自顶向下，从抽象到具体**。那些都属于【上层建筑】，而数组和链表才是【结构基础】。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。

【队列】、【栈】这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。

【图】的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。

【散列表】就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。

【树】，用数组实现就是【堆】，因为【堆】是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种【树】，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表
【树】结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。


（2）数据结构基本操作

对于任何数据结构，其基本操作无非**遍历 + 访问**，再具体一点就是：**增删查改**。

数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非**迭代和递归**。

数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。话说这不就是数据结构的使命么？

如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的**遍历 + 访问**无非两种形式：**线性的和非线性的**。

线性就是 for/while **迭代**为代表，非线性就是**递归（兼具迭代）**为代表。

数组遍历：迭代 ==> 链表遍历：递归（兼具迭代） ==>  二叉树遍历：递归  ==> N叉树的遍历  ==>  图的遍历（可能出现环，用visited表示状态即可）

**只要涉及递归的问题，都是树的问题**，**回溯算法就是个 N 叉树的前后序遍历问题**（N皇后问题）

其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。

（3）链表反转：递归（还有迭代）


### 数据结构(TODO) （🔥🔥🔥）

(1) 并查集:主要是解决图论中【动态连通性】问题的

(2) LRU算法（缓存淘汰策略），LFU算法（最不经常使用）

(3) 堆（大/小根堆）；(295)

(4) 优先队列(23,355)，二叉堆实现优先队列，二叉堆实现堆排序

(5) 单调栈(496,503,739)，单调队列(239)

(6) 队列实现栈，栈实现队列（双栈实现）(232,225)

(7) 二叉堆和平衡二叉搜索树(855)


### 15、双指针(包括特殊的：滑动窗口，二分法)


### 16、O(1)时间删除查找

1、如果想高效地，等概率地随机获取元素，就要使用数组作为底层容器。

2、如果要保持数组元素的紧凑性，可以把待删除元素换到最后，然后 pop 掉末尾的元素，这样时间复杂度就是 O(1) 了。当然，我们需要额外的哈希表记录值到索引的映射。

### 17、原地修改数组

    26.删除排序数组中的重复项：快慢指针
    83.删除排序链表中的重复元素（简单）
    27.移除元素（简单）
    283.移动零（简单）


### 18、时间复杂度和空间复杂度

- 时间复杂度

取复杂度最高的一项作为总体复杂度，忽略常数

        O(1) 加减乘除，数组pop、set，map的get、set
        O(log n)
        O(n) 单层循环
        O(n log n)
        O(n*n) 嵌套循环
        O(n*n*n)
        O(2的n次方，n!)

- 空间复杂度（创建的数据结构）



        O(1) 创建变量
        O(n) 数组和map、set，链表
        O(n*n) 二维数组，或者一维数组存放set、map
        O(log n) 二分搜索
        O(n log n)  排序
        O(n*n) 
        O(n*n*n) 四数之和
        O(2的n次方，n!)


```golang
// O(n) 而不是 O(n*n)
for i < n{
    // 交替运算
    i++
    j:=i
    for j<n{
        i++
    }
}
```



