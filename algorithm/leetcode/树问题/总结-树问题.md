## 二叉树

- 常见二叉树

        满二叉树
        完全二叉树
        二叉搜索树
        平衡二叉树

- 高级二叉树（🔥🔥🔥）

        二叉搜索树
        AVL树
        字典树
        红黑树
        B树，B+树

### 二叉树存储方式（😅 ）

链式存储（指针）、顺序存储（数组 ）

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起

### 二叉树遍历问题

[二叉树遍历golang实现 🔥🔥🔥 ](https://greyireland.gitbook.io/algorithm-pattern/shu-ju-jie-gou-pian/binary_tree#fen-zhi-fa-ying-yong)

- DFS（深度优先遍历）：先往深走，遇到叶子节点再往回走；**递归**和**迭代**两种实现方式。**前中后指的是根节点的遍历顺序**

        144. 前序遍历
        94. 中序遍历
        145. 后序遍历


栈其实就是递归的一种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助  **栈** 使用非递归的方式来实现的。

- BFS（广度优先遍历）：一层一层的去遍历，层序遍历  

**队列**先进先出，符合一层一层遍历的逻辑，而用**栈**先进后出适合模拟深度优先遍历也就是递归的逻辑。

        102. 二叉树的层序遍历
        107. 二叉树的层序遍历 II
        199. 二叉树的右视图
        637. 二叉树的层平均值
        429. N 叉树的层序遍历
        515. 在每个树行中找最大值
        116. 填充每个节点的下一个右侧节点指针（😅）
        117. 填充每个节点的下一个右侧节点指针 II（😅 too）


广度优先遍历的实现一般使用 **队列** 来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

- 快速排序、归并排序，典型的分治法应用（ 🔥🔥🔥 ）


### 二叉树【深度】、【高度】

求深度可以【从上到下】去查 所以需要**前序遍历（中左右）**，而高度只能【从下到上】去查，所以只能**后序遍历（左右中）**

### 二叉树递归遍历

```golang
    // 递归算法的三个要素 🔥
    // (1) 确定递归函数的参数和返回值
    func PreorderTraversal(root *TreeNode) (res []int)
    // (2) 确定终止条件 base case
    if node == nil {
        return
	}
    // (3) 确定单层递归的逻辑
    res = append(res,node.Val)
	traversal(node.Left)
	traversal(node.Right)
```

### 二叉树重建

前序和中序可以唯一确定一颗二叉树。

后序和中序可以唯一确定一颗二叉树。

前序和后序不能唯一确定一颗二叉树！，因为没有中序遍历无法确定左右部分，也就是无法分割。

### 树的灵活应用

所有**回溯、动归、分治算法**，其实都是树的问题；**【快速排序】**就是个二叉树的【前序遍历】，**【归并排序】**就是个二叉树的【后续遍历】

快速排序：先构造分界点，然后去左右子数组构造分界点

归并排序：先对左右子数组排序，然后合并（类似合并有序链表的逻辑）


### 写递归算法的秘诀

**写递归算法的关键是要明确函数的【定义】是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。**

写树相关的算法，简单说就是，先搞清楚当前 root 节点该做什么，然后根据函数定义递归调用子节点

二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情。

写二叉树的算法题，都是基于递归框架的，我们先要搞清楚 root 节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。

### 搜索二叉树

BST特性（🔥🔥🔥）：中序遍历结果是有序的（升序）

直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

```golang
    // BST增删改查套路 
    func BST(root *TreeNode, target int) *TreeNode {
        if root.Val == target {
            // 目标节点
        } else if root.Val > target {
            BST(root.Left, target)
        } else if root.Val < target {
            BST(root.Right, target)
        }
    }
```

## 总结：

**把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了**

### 二叉树题目

    144. 二叉树的前序遍历
    94. 二叉树的中序遍历
    145. 二叉树的后序遍历

    98. 验证二叉搜索树
    701. 二叉搜索树中的插入操作
    450. 删除二叉搜索树中的节点
    110. 平衡二叉树
    226. 翻转二叉树
    104. 二叉树的最大深度
    559. N叉树的最大深度

    257. 二叉树的所有路径（递归中隐藏着回溯 question 😅😅😅）
    110.平衡二叉树
    222.完全二叉树的节点个数
    100. 相同的树
    404. 左叶子之和
    513. 找树左下角的值
    112. 路径总和 （递归中隐藏着回溯 question 😅😅😅）
    113. 路径总和 II （递归+回溯 😅😅😅）

    105. 从前序与中序遍历序列构造二叉树  （😅😅😅）
    106. 从中序与后序遍历序列构造二叉树  （😅😅😅）




    