### 二叉树遍历问题

[二叉树遍历golang 🔥🔥🔥 ](https://greyireland.gitbook.io/algorithm-pattern/shu-ju-jie-gou-pian/binary_tree#fen-zhi-fa-ying-yong)

- 前序遍历（144）
- 中序遍历（94）
- 后序遍历（145）
- BFS层序遍历（宽度优先遍历 question 😅😅😅😅😅😅）
- DFS深度搜索（从上到下、从下到上（分治法））
- 快速排序、归并排序，典型的分治法应用（ 🔥🔥🔥 ）

```golang
// 递归实现（🔥🔥🔥）
traverse(root *TreeNode) {
    // 前序遍历
    traverse(root.Left)
    // 中序遍历
    traverse(root.Right)
    // 后序遍历
}
```
```golang
// 迭代实现（🔥🔥🔥）
traverse(root *TreeNode) {
    if root == nil {
        return root
    }
    queue := make([]*TreeNode, 0)
    queue = append(queue, root)
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        // 前序遍历
        if node.Left != nil {
            queue = append(queue, node.Left)
        }
        // 中序遍历
        if node.Right != nil {
            queue = append(queue, node.Right)
        }
        // 后序遍历
    }
}
```

### 树的灵活应用

所有**回溯、动归、分治算法**，其实都是树的问题


    【快速排序】就是个二叉树的【前序遍历】，【归并排序】就是个二叉树的【后续遍历】

快速排序：先构造分界点，然后去左右子数组构造分界点

归并排序：先对左右子数组排序，然后合并（类似合并有序链表的逻辑）

### 写递归算法的秘诀

    写递归算法的关键是要明确函数的【定义】是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

写树相关的算法，简单说就是，先搞清楚当前 root 节点该做什么，然后根据函数定义递归调用子节点

二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情。

写二叉树的算法题，都是基于递归框架的，我们先要搞清楚 root 节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。

### 搜索二叉树

BST特性（🔥🔥🔥）：中序遍历结果是有序的（升序）

直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

```golang
    // BST增删改查套路 
    func BST(root *TreeNode, target int) *TreeNode {
        if root.Val == target {
            // 目标节点
        } else if root.Val > target {
            BST(root.Left, target)
        } else if root.Val < target {
            BST(root.Right, target)
        }
    }
```

总结：

**把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了**