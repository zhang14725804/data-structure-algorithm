/*
	ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ï¼Œa1, a2, ..., an, å’Œä¸€ä¸ªç›®æ ‡æ•°ï¼ŒSã€‚ç°åœ¨ä½ æœ‰ä¸¤ä¸ªç¬¦å·Â +Â å’ŒÂ -ã€‚
	å¯¹äºæ•°ç»„ä¸­çš„ä»»æ„ä¸€ä¸ªæ•´æ•°ï¼Œä½ éƒ½å¯ä»¥ä»Â +Â æˆ–Â -ä¸­é€‰æ‹©ä¸€ä¸ªç¬¦å·æ·»åŠ åœ¨å‰é¢ã€‚

	è¿”å›å¯ä»¥ä½¿æœ€ç»ˆæ•°ç»„å’Œä¸ºç›®æ ‡æ•° S çš„æ‰€æœ‰æ·»åŠ ç¬¦å·çš„æ–¹æ³•æ•°ã€‚

	æ•°ç»„éç©ºï¼Œä¸”é•¿åº¦ä¸ä¼šè¶…è¿‡ 20 ã€‚
	åˆå§‹çš„æ•°ç»„çš„å’Œä¸ä¼šè¶…è¿‡ 1000 ã€‚
	ä¿è¯è¿”å›çš„æœ€ç»ˆç»“æœèƒ½è¢« 32 ä½æ•´æ•°å­˜ä¸‹ã€‚

*/

/*
	æ–¹æ³•1ï¼šå›æº¯ç®—æ³•
	question ğŸ˜…ğŸ˜…ğŸ˜… è¿™é“é¢˜ä¸ºä»€ä¹ˆä¸éœ€è¦forå¾ªç¯ ğŸ˜…ğŸ˜…ğŸ˜…
*/
var ans int
var nums []int
var target int

func findTargetSumWays(N []int, T int) int {
	target = T
	nums = N
	backtrack(0)
	return ans
}
func backtrack(i int) {
	if i == len(nums) {
		if target == 0 {
			ans++
		}
		return
	}
	// é€‰æ‹©åŠ å·
	target += nums[i]
	backtrack(i + 1)
	target -= nums[i]
	// é€‰æ‹©å‡å·
	target -= nums[i]
	backtrack(i + 1)
	target += nums[i]

}

// æ–¹æ³•2ï¼šé€’å½’+cache
func findTargetSumWays(nums []int, target int) int {

}

/*
	æ–¹æ³•3ï¼šåŠ¨æ€è§„åˆ’ï¼ŒèƒŒåŒ…é—®é¢˜
	å¦‚ä½•è½¬åŒ–ä¸º01èƒŒåŒ…é—®é¢˜å‘¢ã€‚ ï¼ˆğŸ˜…ğŸ˜…ğŸ˜…ï¼‰
*/
func findTargetSumWays(nums []int, target int) int {
	sum := 0
	for _, v := range nums {
		sum += v
	}
	if target > sum {
		return 0
	}
	if (target+sum)%2 == 1 {
		return 0
	}
	// æ­¤æ—¶é—®é¢˜å°±è½¬åŒ–ä¸ºï¼Œè£…æ»¡å®¹é‡ä¸ºxèƒŒåŒ…ï¼Œæœ‰å‡ ç§æ–¹æ³•
	bgSize := (target + sum) / 2
	// dp[j] è¡¨ç¤ºï¼šå¡«æ»¡jï¼ˆåŒ…æ‹¬jï¼‰è¿™ä¹ˆå¤§å®¹ç§¯çš„åŒ…ï¼Œæœ‰dp[i]ç§æ–¹æ³•
	dp := make([]int, bgSize+1)
	// åˆå§‹åŒ–ã€‚dp[0] = 1ï¼Œç†è®ºä¸Šä¹Ÿå¾ˆå¥½è§£é‡Šï¼Œè£…æ»¡å®¹é‡ä¸º0çš„èƒŒåŒ…ï¼Œæœ‰1ç§æ–¹æ³•ï¼Œå°±æ˜¯è£…0ä»¶ç‰©å“
	dp[0] = 1
	for i := 0; i < len(nums); i++ {
		for j := bgSize; j >= nums[i]; j-- {
			// ğŸ˜…ğŸ˜…ğŸ˜… é€’å½’å…¬å¼ï¼Œæ±‚è£…æ»¡èƒŒåŒ…æœ‰å‡ ç§æ–¹æ³•çš„æƒ…å†µğŸ˜…ğŸ˜…ğŸ˜…
			dp[j] += dp[j-nums[i]]
		}
	}
	return dp[bgSize]
}