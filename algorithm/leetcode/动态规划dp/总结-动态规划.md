## 动态规划


### 什么是动态规划

符合动态规划的特征：**重叠子问题、最优子结构**

动态规划就是把大问题变成小问题，并解决了小问题重复计算（**重叠问题**）的方法称为【动态规划】

动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于【贪心】，贪心没有状态推导，而是从局部直接选最优的，

- 动态规划、递归、回溯的区别联系

        递归：自顶向下，存在重叠子问题
        dp：自底向上；cache或DP table解决递归中的重叠子问题；穷举+剪枝



**动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题**

### 动态规划套路


1. 套路1-闫氏解题法

dp问题可分为：状态表示（分为：集合，属性）和状态计算

2. 套路2-labuladong

如何列出正确的状态转移方程？

    第一步要明确两点，「状态」和「选择」
    第二步要明确dp数组的定义
    第三步，根据「选择」，思考状态转移的逻辑

    （1）确定 base case
    （2）确定【状态】，也就是原问题和子问题中会变化的变量
    （3）确定【选择】，也就是导致【状态】产生变化的行为
    （4）明确 dp 函数/数组的定义

3. 套路3-youngyangyang04

        （1）确定dp数组（dp table）以及下标的含义
        （2）确定递推公式
        （3）dp数组如何初始化
        （4）确定遍历顺序
        （5）举例推导dp数组

### question

        （1）遍历方向；有时候正向(72)，有时候反向(516)
        （2）开辟dp数组；有时开辟n+1,m+1的空间(72)，有时开辟n空间(516)
        （3）如何进行状态压缩
        （4）背包问题(494)

### 动态规划应该如何debug

找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！

做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。


        这道题目我举例推导状态转移公式了么？
        我打印dp数组的日志了么？
        打印出来了dp数组和我想的一样么？


只要涉及子序列问题，十有八九都需要动态规划来解决  

### 具体题型

        509. 斐波那契数（n+1）
        70. 爬楼梯（😅 n+1） （1）为什么n+1；（2）从dfs进化到dp再进行状态压缩
        746. 使用最小花费爬楼梯（ 😅 n ）
        62. 不同路径（dp、dfs 😅）
        63. 不同路径 II（dp、dfs 障碍物 ）
        343. 整数拆分（还是不会 n+1 😅）
        96. 不同的二叉搜索树

        72. 编辑距离

        120 递归或者动态规划
        45 jump Game
        55 jump Game



## 背包问题

        416. 分割等和子集
        1049. 最后一块石头的重量 II
        494. 目标和（如何转化为01背包问题呢。 😅😅😅）
        474. 一和零（如何转化为01背包问题呢。 😅😅😅）

### 0-1背包问题

有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。


（2）确定递推公式

由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]

由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])


```c++
void bag_problem_01() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // （1） 😅😅😅 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));

    /*
        （3）dp数组如何初始化
        首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0
        状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。
        dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值
    */ 
    for (int j = weight[0]; j <= bagWeight; j++) {
        dp[0][j] = value[0];
    }
    /*
        （4）确定遍历顺序
        两个遍历的维度：物品与背包重量
    */
    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagWeight] << endl;
}
```

### 0-1背包状态压缩（滚动数组 😅😅😅 ）

        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);

于其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

（1）😅😅😅 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。


（2）一维dp数组的递推公式       

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j]，一个是取dp[j - weight[i]] + value[i]，指定是取最大的，毕竟是求最大价值，

dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);


（3）一维dp数组如何初始化

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

（4）一维dp数组遍历顺序 （😅😅😅😅😅😅😅😅😅）

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小

倒叙遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

那么问题又来了，为什么二维dp数组历的时候不用倒叙呢？

因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！

再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？不可以

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

```c++
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```


- 完全背包问题


        0-1背包问题(416)
        完全背包问题(518)


- 其他经典问题

        正则表达式匹配(10,44)
        高楼扔鸡蛋
        买卖股票问题
        1.5****TODO