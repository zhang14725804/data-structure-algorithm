/*
	ç»™å®šæ•°ç»„Â Aï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œç…é¥¼ç¿»è½¬ï¼šæˆ‘ä»¬é€‰æ‹©ä¸€äº›æ­£æ•´æ•°Â kÂ <= A.lengthï¼Œç„¶ååè½¬ A çš„å‰ kÂ ä¸ªå…ƒç´ çš„é¡ºåºã€‚æˆ‘ä»¬è¦æ‰§è¡Œé›¶æ¬¡æˆ–å¤šæ¬¡ç…é¥¼ç¿»è½¬ï¼ˆæŒ‰é¡ºåºä¸€æ¬¡æ¥ä¸€æ¬¡åœ°è¿›è¡Œï¼‰ä»¥å®Œæˆå¯¹æ•°ç»„ A çš„æ’åºã€‚
	è¿”å›èƒ½ä½¿Â A æ’åºçš„ç…é¥¼ç¿»è½¬æ“ä½œæ‰€å¯¹åº”çš„ k å€¼åºåˆ—ã€‚ä»»ä½•å°†æ•°ç»„æ’åºä¸”ç¿»è½¬æ¬¡æ•°åœ¨Â 10 * A.length èŒƒå›´å†…çš„æœ‰æ•ˆç­”æ¡ˆéƒ½å°†è¢«åˆ¤æ–­ä¸ºæ­£ç¡®ã€‚
*/

/*
	æ–¹æ³•1ï¼šé€’å½’
	1ã€æ‰¾åˆ°nä¸ªé¥¼ä¸­æœ€å¤§çš„é‚£ä¸ªã€‚
	2ã€æŠŠè¿™ä¸ªæœ€å¤§çš„é¥¼ç§»åˆ°æœ€åº•ä¸‹ã€‚
	3ã€é€’å½’è°ƒç”¨pancakeSort(A, n - 1)ã€‚
	base caseï¼šn == 1æ—¶ï¼Œæ’åº 1 ä¸ªé¥¼æ—¶ä¸éœ€è¦ç¿»è½¬ã€‚
	ã€å¦‚ä½•è®¾æ³•å°†æŸå—çƒ§é¥¼ç¿»åˆ°æœ€åå‘¢ï¼Ÿã€‘
	æ¯”å¦‚ç¬¬ 3 å—é¥¼æ˜¯æœ€å¤§çš„ï¼Œæˆ‘ä»¬æƒ³æŠŠå®ƒæ¢åˆ°æœ€åï¼Œä¹Ÿå°±æ˜¯æ¢åˆ°ç¬¬nå—ã€‚å¯ä»¥è¿™æ ·æ“ä½œï¼š
	1ã€ç”¨é”…é“²å°†å‰ 3 å—é¥¼ç¿»è½¬ä¸€ä¸‹ï¼Œè¿™æ ·æœ€å¤§çš„é¥¼å°±ç¿»åˆ°äº†æœ€ä¸Šé¢ã€‚
	2ã€ç”¨é”…é“²å°†å‰nå—é¥¼å…¨éƒ¨ç¿»è½¬ï¼Œè¿™æ ·æœ€å¤§çš„é¥¼å°±ç¿»åˆ°äº†ç¬¬nå—ï¼Œä¹Ÿå°±æ˜¯æœ€åä¸€å—ã€‚
*/

var res []int

func pancakeSort(arr []int) []int {
	dfs(arr, len(arr))
	return res
}

// å¯æƒœä¸æ˜¯æœ€ä¼˜è§£ ğŸ˜…
// question è®¡ç®—æ’åºçƒ§é¥¼çš„ã€æœ€çŸ­ã€‘æ“ä½œåºåˆ—ï¼Œåº”è¯¥æ˜¯è¦ç”¨BFSï¼ˆä¸å¯¹ï¼Œå›æº¯æ±‚å‡ºæ‰€æœ‰å¯è¡Œçš„è§£ç„¶åæ‰¾åˆ°æœ€ä¼˜è§£ï¼‰ï¼Œé—®é¢˜æ˜¯æ€ä¹ˆå†™ğŸ˜…
func dfs(cakes []int, n int) {
	// base case
	if n == 1 {
		return
	}
	// å¯»æ‰¾æœ€å¤§çš„é¥¼ç´¢å¼•
	maxCake := 0
	maxCakeIndex := 0
	for i := 0; i < len(cakes); i++ {
		if cakes[i] > maxCake {
			maxCake = cakes[i]
			maxCakeIndex = i
		}
	}
	// ç¬¬ä¸€æ¬¡åè½¬
	reverse(cakes, 0, maxCakeIndex)
	res = append(res, maxCakeIndex+1)
	// ç¬¬äºŒæ¬¡åè½¬
	reverse(cakes, 0, n-1)
	res = append(res, n)
	// é€’å½’è°ƒç”¨
	dfs(cakes, n-1)
}
func reverse(cakes []int, i, j int) {
	for i < j {
		cakes[i], cakes[j] = cakes[j], cakes[i]
		i++
		j--
	}
}
	