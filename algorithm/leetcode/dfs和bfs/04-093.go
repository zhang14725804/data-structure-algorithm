/*
	ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸²ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª IP åœ°å€ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½ä» s è·å¾—çš„ æœ‰æ•ˆ IP åœ°å€ ã€‚ä½ å¯ä»¥æŒ‰ä»»ä½•é¡ºåºè¿”å›ç­”æ¡ˆã€‚
	æœ‰æ•ˆ IP åœ°å€ æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº 0 åˆ° 255 ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ 0ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ '.' åˆ†éš”ã€‚
	ä¾‹å¦‚ï¼š"0.1.2.201" å’Œ "192.168.1.1" æ˜¯ æœ‰æ•ˆ IP åœ°å€ï¼Œä½†æ˜¯ "0.011.255.245"ã€"192.168.1.312" å’Œ "192.168@1.1" æ˜¯ æ— æ•ˆ IP åœ°å€ã€‚
*/
var ans []string
var s string

func restoreIpAddresses(_s string) []string {
	var path string
	s = _s
	helper(0, 0, path)
	return ans
}

/*
	u å­—ç¬¦ä¸²ä¸‹æ ‡
	k åˆ†ç»„ä¸‹æ ‡ï¼ˆipç”±å››ä¸ªåˆ†ç»„æ„æˆï¼‰
*/
func helper(u, k int, path string) {
	// base case ğŸ˜…ğŸ˜…ğŸ˜…
	if u == len(s) {
		if k == 4 {
			ans = append(ans, path[1:])
			return
		}
	}
	// ä¸æ»¡è¶³æ¡ä»¶pass
	if k > 4 {
		return
	}
	// å½“å‰è¿™ä¸€ä½æ˜¯0ï¼Œåªèƒ½æ˜¯å•ç‹¬çš„ä¸€ä¸ªæ•°ï¼Œä¾‹å¦‚ï¼š103.0.169.39
	if s[u] == '0' {
		//
		helper(u+1, k+1, path+".0")
	} else {
		// 23,1ï¼›23*10 + 1
		for i, t := u, 0; i < len(s); i++ {
			// ğŸ˜… byteè½¬int
			si, _ := strconv.Atoi(string(s[i]))
			t = t*10 + si
			if t < 256 {
				helper(i+1, k+1, path+"."+strconv.Itoa(t))
			} else {
				break
			}
		}
	}
}