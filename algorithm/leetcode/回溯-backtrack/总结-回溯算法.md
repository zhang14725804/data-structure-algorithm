## 回溯算法

### 回溯算法简介

DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置

因为回溯的本质是【穷举】，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

**用递归控制for循环嵌套的数量！for循环横向遍历，递归纵向遍历，回溯不断调整结果集。**

### 回溯解决的问题

        组合问题：N个数里面按一定规则找出k个数的集合
        切割问题：一个字符串按一定规则有几种切割方式
        子集问题：一个N个数的集合里有多少符合条件的子集
        排列问题：N个数按一定规则全排列，有几种排列方式
        棋盘问题：N皇后，解数独等等


【组合】是不强调元素顺序的，【排列】是强调元素顺序。

### 如何理解回溯


回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。

### 回溯算法套路

只需要思考 3 个问题：

	1、路径：也就是已经做出的选择。
	2、选择列表：也就是你当前可以做的选择。
	3、结束条件：也就是到达决策树底层，无法再做选择的条件。

其核心就是 for 循环里面的递归，在递归调用之前【做选择】，在递归调用之后【撤销选择】



```golang
func backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
// 路径，选择列表
func backtrack(nums []int, u int) {
	// 结束条件
	if u == n {
                // 😅😅😅 由于golang中slice特性
		c := make([]int, n)
		copy(c, path)
		ans = append(ans, c)
		return
        }
    
	for i := 0; i < n; i++ {
                // 做选择
                st[i] = true
                path = append(path, nums[i])
                // 递归下一层
                backtrack(nums, u+1)
                // 撤销选择
                st[i] = false
                path = path[:len(path)-1]
	}
}
```

### 如何剪枝 😅😅😅

剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了。

### 回溯算法题目

- 组合问题

对于组合问题，什么时候需要start呢？

        如果是一个集合来求组合的话，就需要start
        如果是多个集合取组合，各个集合之间相互不影响，那么就不用start

        77. 组合（剪枝 😅）
        216. 组合总和 III
        39. 组合总和
        40. 组合总和 II（ 困难，“树层去重”和“树枝去重” 😅😅😅 去重一定要对元素经行排序  三种去重方式 😅😅😅）
        17. 电话号码的字母组合

- 分割问题


        131. 分割回文串（😅😅😅 困难）
        93. 复原 IP 地址（字符串问题 困扰了很久 😅）

- 子集问题

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么【组合问题】和【分割问题】都是收集树的【叶子节点】，而【子集问题】是找树的【所有节点】！

其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。

那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从start开始，而不是从0开始！

        78. 子集（没想出来终止条件 😅）
        90. 子集 II （ 困难，“树层去重”和“树枝去重” 😅😅😅 去重一定要对元素经行排序  三种去重方式 😅😅😅 ）

- 排列问题

        每层都是从0开始搜索而不是start
        需要used数组记录path里都放了哪些元素了

        46. 全排列
        47. 全排列 II （ 困难，“树层去重”和“树枝去重” 😅😅😅 去重一定要对元素经行排序  三种去重方式 😅😅😅 😅😅😅😅😅😅 ）
        491. 递增子序列（标记本层已使用 😅😅😅 ，不需要回溯 有坑 😅😅😅）

- 其他

        332. 重新安排行程
        22. 括号生成（困难 😅😅😅 ）
        37. 解数独（困难 😅😅😅 如何标记已经出现/valid函数）
        51. n皇后问题 （困难 😅😅😅  如何标记已经出现/valid函数）


### 回溯算法去重问题

[😅😅😅回溯算法去重问题😅😅😅](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.md)



       