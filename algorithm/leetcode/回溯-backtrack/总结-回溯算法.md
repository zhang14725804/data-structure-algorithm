## 回溯算法

### 回溯算法简介

DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置

因为回溯的本质是【穷举】，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

**用递归控制for循环嵌套的数量！for循环横向遍历，递归纵向遍历，回溯不断调整结果集。**

### 回溯解决的问题

        组合问题：N个数里面按一定规则找出k个数的集合
        切割问题：一个字符串按一定规则有几种切割方式
        子集问题：一个N个数的集合里有多少符合条件的子集
        排列问题：N个数按一定规则全排列，有几种排列方式
        棋盘问题：N皇后，解数独等等


【组合】是不强调元素顺序的，【排列】是强调元素顺序。

### 如何理解回溯


回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。

### 回溯算法套路

只需要思考 3 个问题：

	1、路径：也就是已经做出的选择。
	2、选择列表：也就是你当前可以做的选择。
	3、结束条件：也就是到达决策树底层，无法再做选择的条件。

其核心就是 for 循环里面的递归，在递归调用之前【做选择】，在递归调用之后【撤销选择】



```golang
func backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
// 路径，选择列表
func backtrack(nums []int, u int) {
	// 结束条件
	if u == n {
                // 😅😅😅 由于golang中slice特性
		c := make([]int, n)
		copy(c, path)
		ans = append(ans, c)
		return
        }
    
	for i := 0; i < n; i++ {
                // 做选择
                st[i] = true
                path = append(path, nums[i])
                // 递归下一层
                backtrack(nums, u+1)
                // 撤销选择
                st[i] = false
                path = path[:len(path)-1]
	}
}
```

### 如何剪枝 😅😅😅

剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了。

### 回溯算法题目

- 组合问题

如果是一个集合来求组合的话，就需要start

如果是多个集合取组合，各个集合之间相互不影响，那么就不用start

        77.组合（剪枝 😅）
        216. 组合总和 III
        39. 组合总和
        40. 组合总和 II（“树层去重”和“树枝去重” 😅）
        17. 电话号码的字母组合

        131. 分割回文串（😅😅😅 困难）
        93. 复原 IP 地址
        22.括号生成
        37.解数独
        78.子集
        46. 全排列
        47. 全排列 II
        51.n皇后问题
        90. 子集 II


       