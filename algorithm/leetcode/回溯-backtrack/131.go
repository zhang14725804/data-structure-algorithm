/*
	ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œå°† s åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯å›æ–‡ä¸²ã€‚
	è¿”å› s æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚

	æ€è·¯ï¼šs[i,j]æ˜¯å›æ–‡ä¸²ï¼Œé‚£ä¹ˆs[i+1,j-1]ä¹Ÿæ˜¯å›æ–‡ä¸²

*/

/*
	æ–¹æ³•ï¼šå›æº¯

	æ¶‰åŠåˆ°çš„é—®é¢˜ï¼ˆğŸ˜…ğŸ˜…ğŸ˜…ï¼‰ï¼š
	åˆ‡å‰²é—®é¢˜å¯ä»¥æŠ½è±¡ä¸ºç»„åˆé—®é¢˜
	å¦‚ä½•æ¨¡æ‹Ÿé‚£äº›åˆ‡å‰²çº¿
	åˆ‡å‰²é—®é¢˜ä¸­é€’å½’å¦‚ä½•ç»ˆæ­¢
	åœ¨é€’å½’å¾ªç¯ä¸­å¦‚ä½•æˆªå–å­ä¸²
	å¦‚ä½•åˆ¤æ–­å›æ–‡

	å…¶å®åˆ‡å‰²é—®é¢˜ç±»ä¼¼ç»„åˆé—®é¢˜
	é€’å½’ç”¨æ¥ã€çºµå‘éå†ã€‘ï¼Œforå¾ªç¯ç”¨æ¥ã€æ¨ªå‘éå†ã€‘ï¼Œåˆ‡å‰²çº¿ï¼ˆå°±æ˜¯å›¾ä¸­çš„çº¢çº¿ï¼‰åˆ‡å‰²åˆ°å­—ç¬¦ä¸²çš„ç»“å°¾ä½ç½®ï¼Œè¯´æ˜æ‰¾åˆ°äº†ä¸€ä¸ªåˆ‡å‰²æ–¹æ³•ã€‚
*/
var ans [][]string
var path []string
var str string

func partition(s string) [][]string {
	str = s
	ans = make([][]string, 0) // åªæ˜¯ä¸ºäº†æäº¤ï¼Œleetcodeæäº¤æ—¶ï¼Œans ä¼šæ‹¼æ¥ä¹‹å‰æäº¤çš„ç»“æœ
	backtrack(0)
	return ans
}

/*
	åœ¨å¤„ç†ç»„åˆé—®é¢˜çš„æ—¶å€™ï¼Œé€’å½’å‚æ•°éœ€è¦ä¼ å…¥ start ï¼Œè¡¨ç¤ºä¸‹ä¸€è½®é€’å½’éå†çš„èµ·å§‹ä½ç½®ï¼Œè¿™ä¸ª start å°±æ˜¯åˆ‡å‰²çº¿
*/
func backtrack(start int) {
	// å¦‚æœèµ·å§‹ä½ç½®å·²ç»å¤§äºsçš„å¤§å°ï¼Œè¯´æ˜å·²ç»æ‰¾åˆ°äº†ä¸€ç»„åˆ†å‰²æ–¹æ¡ˆäº†
	if start >= len(str) {
		back := make([]string, len(path))
		copy(back, path)
		ans = append(ans, back)
		return
	}
	for i := start; i < len(str); i++ {
		// æ˜¯å›æ–‡å­ä¸²
		if isPalindrome(str[start : i+1]) {
			path = append(path, str[start:i+1])
		} else {
			// ä¸æ˜¯å›æ–‡ï¼Œè·³è¿‡
			continue
		}
		// ğŸ˜… åˆ‡å‰²è¿‡çš„ä½ç½®ï¼Œä¸èƒ½é‡å¤åˆ‡å‰²ï¼Œæ‰€ä»¥ï¼Œbacktracking(s, i + 1); ä¼ å…¥ä¸‹ä¸€å±‚çš„èµ·å§‹ä½ç½®ä¸ºi + 1ã€‚
		backtrack(i + 1)
		path = path[:len(path)-1]
	}
}

func isPalindrome(str string) bool {
	for i, j := 0, len(str)-1; i < j; i, j = i+1, j-1 {
		if str[i] != str[j] {
			return false
		}
	}
	return true
}