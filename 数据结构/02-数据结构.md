### 01、数组

- 第一：线性表(Linear List)。顾名思义,线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组,链表、队
列、栈等也是线性表结构。

- 第二：连续的内存空间和相同类型的数据。正是因为这两个限制,它才有了一个堪称“杀手锏”的特性:“随机访问”。但有利就有弊,这两个限制也让数组的很多
操作变得非常低效,比如要想在数组中删除、插入一个数据,为了保证连续性,就需要做大量的数据搬移工作。（todo：如何规避低效的插入（先移动后替换）和删除（多次操作合并））

- 为什么大多数编程语言中,数组要从0开始编号,而不是从1开始呢?

    从数组存储的内存模型上来看,“下标”最确切的定义应该是“**偏移(offset)**”。前面也讲到,如果用a来表示数组的首地址,a[0]就是偏移为0的位置,也就是首地
    址,a[k]就表示偏移k个type_size的位置,所以计算a[k]的内存地址只需要用这个公式:

    a[k]_address = base_address + k * type_size

    但是,如果数组从1开始计数,那我们计算数组元素a[k]的内存地址就会变为:

    a[k]_address = base_address + (k-1)*type_size

    对比两个公式,我们不难发现,从1开始编号,每次随机访问数组元素都多了一次减法运算,对于CPU来说,就是多了一次减法指令。

    数组作为非常基础的数据结构,通过下标随机访问数组元素又是其非常基础的编程操作,效率的优化就要尽可能做到极致。所以为了减少一次减法操作,数组选
    择了从0开始编号,而不是从1开始。


### 02、链表（常见的：单链表、双链表、循环链表（首尾相连））

缓存的大小有限,当缓存被用满时,哪些数据应该被清理出去,哪些数据应该被保留?这就需要缓存淘汰策略来决定。常见的策略有三种:
**先进先出策略FIFO(First In,First Out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)**。

数组简单易用,在实现上使用的是连续的内存空间,可以借助**CPU的缓存机制**（todo：这是什么鬼）,预读数组中的数据,所以访问效率更高。而链表在内存中并不是连续存储,所以
对CPU缓存不友好,没办法有效预读。

CPU在从内存读取数据的时候,会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址,而是读取一个
数据块(这个大小我不太确定。。)并保存到CPU缓存中,然后下次访问内存数据的时候就会先从CPU缓存开始查找,如果找到就不需要再从内存中取。这样
就实现了比内存访问速度更快的机制,也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说,存储空间是连续的,所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存
储。

怎么理解指针：

    将某个变量赋值给指针,实际上就是将这个变量的地址赋值给指针,或者反过来说,指针中存储了这个变量的内存地址,指向了这个变量,通过指针就能找到这个变量。


### 03、栈（后进先出）：顺序栈（基于数组）和链式栈（基于链表）

栈的应用：

    浏览器前进后退，函数调用栈，匹配括号，表达式求值


### 04、队列（循环队列，阻塞队列，并发队列）：顺序队列和链式队列

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说,就是在队列为空的时候,从队头取数据会被阻塞。因为此时还没有数据可取,直到队列中有了数据
才能返回;如果队列已经满了,那么插入数据的操作就会被阻塞,直到队列中有空闲位置后再插入数据,然后再返回。

线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁,但是锁粒度大并发度会比较低,同一时刻仅允许一个存或
者取操作。实际上,基于数组的循环队列,利用CAS原子操作,可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

### 05、递归（堆栈溢出、重复计算、递归改为非递归问题）

递归求解问题的分解过程,去的过程叫“递”,回来的过程叫“归”。基本上,所有的递归问题都可以用递推公式来表示


